// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assignments.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countAssignmentsByStatus = `-- name: CountAssignmentsByStatus :one
SELECT status, COUNT(*) as count
FROM assignments
GROUP BY status
`

type CountAssignmentsByStatusRow struct {
	Status AssignmentStatus
	Count  int64
}

func (q *Queries) CountAssignmentsByStatus(ctx context.Context) (CountAssignmentsByStatusRow, error) {
	row := q.db.QueryRowContext(ctx, countAssignmentsByStatus)
	var i CountAssignmentsByStatusRow
	err := row.Scan(&i.Status, &i.Count)
	return i, err
}

const createAssignment = `-- name: CreateAssignment :one
INSERT INTO assignments (
    outage_id,
    crew_id,
    status,
    notes
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id
`

type CreateAssignmentParams struct {
	OutageID int64
	CrewID   int64
	Status   AssignmentStatus
	Notes    sql.NullString
}

func (q *Queries) CreateAssignment(ctx context.Context, arg CreateAssignmentParams) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, createAssignment,
		arg.OutageID,
		arg.CrewID,
		arg.Status,
		arg.Notes,
	)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.CrewID,
		&i.Status,
		&i.Notes,
		&i.AssignedAt,
		&i.UpdatedAt,
		&i.PublicID,
	)
	return i, err
}

const deleteAssignment = `-- name: DeleteAssignment :exec
DELETE FROM assignments
WHERE id = $1
`

func (q *Queries) DeleteAssignment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAssignment, id)
	return err
}

const deleteAssignmentByOutageAndCrew = `-- name: DeleteAssignmentByOutageAndCrew :exec
DELETE FROM assignments
WHERE outage_id = $1 AND crew_id = $2
`

type DeleteAssignmentByOutageAndCrewParams struct {
	OutageID int64
	CrewID   int64
}

func (q *Queries) DeleteAssignmentByOutageAndCrew(ctx context.Context, arg DeleteAssignmentByOutageAndCrewParams) error {
	_, err := q.db.ExecContext(ctx, deleteAssignmentByOutageAndCrew, arg.OutageID, arg.CrewID)
	return err
}

const getAssignment = `-- name: GetAssignment :one
SELECT id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id FROM assignments
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAssignment(ctx context.Context, id int64) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, getAssignment, id)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.CrewID,
		&i.Status,
		&i.Notes,
		&i.AssignedAt,
		&i.UpdatedAt,
		&i.PublicID,
	)
	return i, err
}

const getAssignmentByOutageAndCrew = `-- name: GetAssignmentByOutageAndCrew :one
SELECT id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id FROM assignments
WHERE outage_id = $1 AND crew_id = $2 LIMIT 1
`

type GetAssignmentByOutageAndCrewParams struct {
	OutageID int64
	CrewID   int64
}

func (q *Queries) GetAssignmentByOutageAndCrew(ctx context.Context, arg GetAssignmentByOutageAndCrewParams) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, getAssignmentByOutageAndCrew, arg.OutageID, arg.CrewID)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.CrewID,
		&i.Status,
		&i.Notes,
		&i.AssignedAt,
		&i.UpdatedAt,
		&i.PublicID,
	)
	return i, err
}

const getAssignmentByPublicID = `-- name: GetAssignmentByPublicID :one
SELECT id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id FROM assignments
WHERE public_id = $1 LIMIT 1
`

func (q *Queries) GetAssignmentByPublicID(ctx context.Context, publicID uuid.UUID) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, getAssignmentByPublicID, publicID)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.CrewID,
		&i.Status,
		&i.Notes,
		&i.AssignedAt,
		&i.UpdatedAt,
		&i.PublicID,
	)
	return i, err
}

const getAssignmentWithDetails = `-- name: GetAssignmentWithDetails :one
SELECT 
    a.id, a.outage_id, a.crew_id, a.status, a.notes, a.assigned_at, a.updated_at, a.public_id,
    o.public_id as outage_public_id,
    o.title as outage_title,
    o.status as outage_status,
    o.description as outage_description,
    c.public_id as crew_public_id,
    c.name as crew_name,
    c.crew_type as crew_type,
    c.description as crew_description
FROM assignments a
JOIN outages o ON a.outage_id = o.id
JOIN crews c ON a.crew_id = c.id
WHERE a.id = $1
`

type GetAssignmentWithDetailsRow struct {
	ID                int64
	OutageID          int64
	CrewID            int64
	Status            AssignmentStatus
	Notes             sql.NullString
	AssignedAt        time.Time
	UpdatedAt         sql.NullTime
	PublicID          uuid.UUID
	OutagePublicID    uuid.UUID
	OutageTitle       sql.NullString
	OutageStatus      OutageStatus
	OutageDescription sql.NullString
	CrewPublicID      uuid.UUID
	CrewName          string
	CrewType          CrewType
	CrewDescription   sql.NullString
}

func (q *Queries) GetAssignmentWithDetails(ctx context.Context, id int64) (GetAssignmentWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getAssignmentWithDetails, id)
	var i GetAssignmentWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.CrewID,
		&i.Status,
		&i.Notes,
		&i.AssignedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.OutagePublicID,
		&i.OutageTitle,
		&i.OutageStatus,
		&i.OutageDescription,
		&i.CrewPublicID,
		&i.CrewName,
		&i.CrewType,
		&i.CrewDescription,
	)
	return i, err
}

const getAssignmentsWithDetails = `-- name: GetAssignmentsWithDetails :many
SELECT 
    a.id, a.outage_id, a.crew_id, a.status, a.notes, a.assigned_at, a.updated_at, a.public_id,
    o.public_id as outage_public_id,
    o.title as outage_title,
    o.status as outage_status,
    c.public_id as crew_public_id,
    c.name as crew_name,
    c.crew_type as crew_type
FROM assignments a
JOIN outages o ON a.outage_id = o.id
JOIN crews c ON a.crew_id = c.id
ORDER BY a.assigned_at DESC
LIMIT $1 OFFSET $2
`

type GetAssignmentsWithDetailsParams struct {
	Limit  int32
	Offset int32
}

type GetAssignmentsWithDetailsRow struct {
	ID             int64
	OutageID       int64
	CrewID         int64
	Status         AssignmentStatus
	Notes          sql.NullString
	AssignedAt     time.Time
	UpdatedAt      sql.NullTime
	PublicID       uuid.UUID
	OutagePublicID uuid.UUID
	OutageTitle    sql.NullString
	OutageStatus   OutageStatus
	CrewPublicID   uuid.UUID
	CrewName       string
	CrewType       CrewType
}

func (q *Queries) GetAssignmentsWithDetails(ctx context.Context, arg GetAssignmentsWithDetailsParams) ([]GetAssignmentsWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAssignmentsWithDetails, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssignmentsWithDetailsRow
	for rows.Next() {
		var i GetAssignmentsWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.CrewID,
			&i.Status,
			&i.Notes,
			&i.AssignedAt,
			&i.UpdatedAt,
			&i.PublicID,
			&i.OutagePublicID,
			&i.OutageTitle,
			&i.OutageStatus,
			&i.CrewPublicID,
			&i.CrewName,
			&i.CrewType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCrewAssignmentsWithOutageDetails = `-- name: GetCrewAssignmentsWithOutageDetails :many
SELECT 
    a.id, a.outage_id, a.crew_id, a.status, a.notes, a.assigned_at, a.updated_at, a.public_id,
    o.public_id as outage_public_id,
    o.title as outage_title,
    o.status as outage_status,
    o.outage_type,
    o.start_time,
    o.estimated_restoration_time
FROM assignments a
JOIN outages o ON a.outage_id = o.id
WHERE a.crew_id = $1
ORDER BY a.assigned_at DESC
`

type GetCrewAssignmentsWithOutageDetailsRow struct {
	ID                       int64
	OutageID                 int64
	CrewID                   int64
	Status                   AssignmentStatus
	Notes                    sql.NullString
	AssignedAt               time.Time
	UpdatedAt                sql.NullTime
	PublicID                 uuid.UUID
	OutagePublicID           uuid.UUID
	OutageTitle              sql.NullString
	OutageStatus             OutageStatus
	OutageType               OutageType
	StartTime                sql.NullTime
	EstimatedRestorationTime sql.NullTime
}

func (q *Queries) GetCrewAssignmentsWithOutageDetails(ctx context.Context, crewID int64) ([]GetCrewAssignmentsWithOutageDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCrewAssignmentsWithOutageDetails, crewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCrewAssignmentsWithOutageDetailsRow
	for rows.Next() {
		var i GetCrewAssignmentsWithOutageDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.CrewID,
			&i.Status,
			&i.Notes,
			&i.AssignedAt,
			&i.UpdatedAt,
			&i.PublicID,
			&i.OutagePublicID,
			&i.OutageTitle,
			&i.OutageStatus,
			&i.OutageType,
			&i.StartTime,
			&i.EstimatedRestorationTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveAssignments = `-- name: ListActiveAssignments :many
SELECT id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id FROM assignments
WHERE status IN ('assigned', 'en_route', 'on_site', 'paused')
ORDER BY assigned_at DESC
`

func (q *Queries) ListActiveAssignments(ctx context.Context) ([]Assignment, error) {
	rows, err := q.db.QueryContext(ctx, listActiveAssignments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assignment
	for rows.Next() {
		var i Assignment
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.CrewID,
			&i.Status,
			&i.Notes,
			&i.AssignedAt,
			&i.UpdatedAt,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignments = `-- name: ListAssignments :many
SELECT id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id FROM assignments
ORDER BY assigned_at DESC
LIMIT $1 OFFSET $2
`

type ListAssignmentsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAssignments(ctx context.Context, arg ListAssignmentsParams) ([]Assignment, error) {
	rows, err := q.db.QueryContext(ctx, listAssignments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assignment
	for rows.Next() {
		var i Assignment
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.CrewID,
			&i.Status,
			&i.Notes,
			&i.AssignedAt,
			&i.UpdatedAt,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsByCrew = `-- name: ListAssignmentsByCrew :many
SELECT id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id FROM assignments
WHERE crew_id = $1
ORDER BY assigned_at DESC
`

func (q *Queries) ListAssignmentsByCrew(ctx context.Context, crewID int64) ([]Assignment, error) {
	rows, err := q.db.QueryContext(ctx, listAssignmentsByCrew, crewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assignment
	for rows.Next() {
		var i Assignment
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.CrewID,
			&i.Status,
			&i.Notes,
			&i.AssignedAt,
			&i.UpdatedAt,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsByOutage = `-- name: ListAssignmentsByOutage :many
SELECT id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id FROM assignments
WHERE outage_id = $1
ORDER BY assigned_at DESC
`

func (q *Queries) ListAssignmentsByOutage(ctx context.Context, outageID int64) ([]Assignment, error) {
	rows, err := q.db.QueryContext(ctx, listAssignmentsByOutage, outageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assignment
	for rows.Next() {
		var i Assignment
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.CrewID,
			&i.Status,
			&i.Notes,
			&i.AssignedAt,
			&i.UpdatedAt,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsByStatus = `-- name: ListAssignmentsByStatus :many
SELECT id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id FROM assignments
WHERE status = $1
ORDER BY assigned_at DESC
LIMIT $2 OFFSET $3
`

type ListAssignmentsByStatusParams struct {
	Status AssignmentStatus
	Limit  int32
	Offset int32
}

func (q *Queries) ListAssignmentsByStatus(ctx context.Context, arg ListAssignmentsByStatusParams) ([]Assignment, error) {
	rows, err := q.db.QueryContext(ctx, listAssignmentsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assignment
	for rows.Next() {
		var i Assignment
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.CrewID,
			&i.Status,
			&i.Notes,
			&i.AssignedAt,
			&i.UpdatedAt,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssignment = `-- name: UpdateAssignment :one
UPDATE assignments
SET 
    outage_id = $2,
    crew_id = $3,
    status = $4,
    notes = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id
`

type UpdateAssignmentParams struct {
	ID       int64
	OutageID int64
	CrewID   int64
	Status   AssignmentStatus
	Notes    sql.NullString
}

func (q *Queries) UpdateAssignment(ctx context.Context, arg UpdateAssignmentParams) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, updateAssignment,
		arg.ID,
		arg.OutageID,
		arg.CrewID,
		arg.Status,
		arg.Notes,
	)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.CrewID,
		&i.Status,
		&i.Notes,
		&i.AssignedAt,
		&i.UpdatedAt,
		&i.PublicID,
	)
	return i, err
}

const updateAssignmentProgress = `-- name: UpdateAssignmentProgress :one
UPDATE assignments
SET 
    status = $2,
    notes = COALESCE($3, notes),
    updated_at = NOW()
WHERE id = $1
RETURNING id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id
`

type UpdateAssignmentProgressParams struct {
	ID     int64
	Status AssignmentStatus
	Notes  sql.NullString
}

func (q *Queries) UpdateAssignmentProgress(ctx context.Context, arg UpdateAssignmentProgressParams) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, updateAssignmentProgress, arg.ID, arg.Status, arg.Notes)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.CrewID,
		&i.Status,
		&i.Notes,
		&i.AssignedAt,
		&i.UpdatedAt,
		&i.PublicID,
	)
	return i, err
}

const updateAssignmentStatus = `-- name: UpdateAssignmentStatus :one
UPDATE assignments
SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, outage_id, crew_id, status, notes, assigned_at, updated_at, public_id
`

type UpdateAssignmentStatusParams struct {
	ID     int64
	Status AssignmentStatus
}

func (q *Queries) UpdateAssignmentStatus(ctx context.Context, arg UpdateAssignmentStatusParams) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, updateAssignmentStatus, arg.ID, arg.Status)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.CrewID,
		&i.Status,
		&i.Notes,
		&i.AssignedAt,
		&i.UpdatedAt,
		&i.PublicID,
	)
	return i, err
}
