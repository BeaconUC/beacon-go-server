// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: crews.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countCrewsByType = `-- name: CountCrewsByType :one
SELECT crew_type, COUNT(*) as count
FROM crews
GROUP BY crew_type
`

type CountCrewsByTypeRow struct {
	CrewType CrewType
	Count    int64
}

func (q *Queries) CountCrewsByType(ctx context.Context) (CountCrewsByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, countCrewsByType)
	var i CountCrewsByTypeRow
	err := row.Scan(&i.CrewType, &i.Count)
	return i, err
}

const createCrew = `-- name: CreateCrew :one
INSERT INTO crews (
    name,
    crew_type,
    description
) VALUES (
    $1, $2, $3
)
RETURNING id, public_id, name, crew_type, description, created_at, updated_at
`

type CreateCrewParams struct {
	Name        string
	CrewType    CrewType
	Description sql.NullString
}

func (q *Queries) CreateCrew(ctx context.Context, arg CreateCrewParams) (Crew, error) {
	row := q.db.QueryRowContext(ctx, createCrew, arg.Name, arg.CrewType, arg.Description)
	var i Crew
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.CrewType,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCrew = `-- name: DeleteCrew :exec
DELETE FROM crews
WHERE id = $1
`

func (q *Queries) DeleteCrew(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCrew, id)
	return err
}

const getAvailableCrews = `-- name: GetAvailableCrews :many
SELECT 
    c.id, c.public_id, c.name, c.crew_type, c.description, c.created_at, c.updated_at,
    COUNT(a.id) FILTER (WHERE a.status IN ('assigned', 'en_route', 'on_site')) as current_assignments_count
FROM crews c
LEFT JOIN assignments a ON c.id = a.crew_id AND a.status IN ('assigned', 'en_route', 'on_site')
GROUP BY c.id
HAVING COUNT(a.id) FILTER (WHERE a.status IN ('assigned', 'en_route', 'on_site')) = 0
ORDER BY c.created_at DESC
`

type GetAvailableCrewsRow struct {
	ID                      int64
	PublicID                uuid.UUID
	Name                    string
	CrewType                CrewType
	Description             sql.NullString
	CreatedAt               time.Time
	UpdatedAt               sql.NullTime
	CurrentAssignmentsCount int64
}

func (q *Queries) GetAvailableCrews(ctx context.Context) ([]GetAvailableCrewsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableCrews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableCrewsRow
	for rows.Next() {
		var i GetAvailableCrewsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.CrewType,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentAssignmentsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCrew = `-- name: GetCrew :one
SELECT id, public_id, name, crew_type, description, created_at, updated_at FROM crews
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCrew(ctx context.Context, id int64) (Crew, error) {
	row := q.db.QueryRowContext(ctx, getCrew, id)
	var i Crew
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.CrewType,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCrewByPublicID = `-- name: GetCrewByPublicID :one
SELECT id, public_id, name, crew_type, description, created_at, updated_at FROM crews
WHERE public_id = $1 LIMIT 1
`

func (q *Queries) GetCrewByPublicID(ctx context.Context, publicID uuid.UUID) (Crew, error) {
	row := q.db.QueryRowContext(ctx, getCrewByPublicID, publicID)
	var i Crew
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.CrewType,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCrewWithAssignments = `-- name: GetCrewWithAssignments :one
SELECT 
    c.id, c.public_id, c.name, c.crew_type, c.description, c.created_at, c.updated_at,
    COUNT(a.id) as active_assignments_count,
    COUNT(a.id) FILTER (WHERE a.status IN ('assigned', 'en_route', 'on_site')) as current_assignments_count
FROM crews c
LEFT JOIN assignments a ON c.id = a.crew_id
WHERE c.id = $1
GROUP BY c.id
`

type GetCrewWithAssignmentsRow struct {
	ID                      int64
	PublicID                uuid.UUID
	Name                    string
	CrewType                CrewType
	Description             sql.NullString
	CreatedAt               time.Time
	UpdatedAt               sql.NullTime
	ActiveAssignmentsCount  int64
	CurrentAssignmentsCount int64
}

func (q *Queries) GetCrewWithAssignments(ctx context.Context, id int64) (GetCrewWithAssignmentsRow, error) {
	row := q.db.QueryRowContext(ctx, getCrewWithAssignments, id)
	var i GetCrewWithAssignmentsRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.CrewType,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveAssignmentsCount,
		&i.CurrentAssignmentsCount,
	)
	return i, err
}

const getCrewsWithAssignmentStats = `-- name: GetCrewsWithAssignmentStats :many
SELECT 
    c.id, c.public_id, c.name, c.crew_type, c.description, c.created_at, c.updated_at,
    COUNT(a.id) as total_assignments_count,
    COUNT(a.id) FILTER (WHERE a.status IN ('assigned', 'en_route', 'on_site')) as current_assignments_count,
    COUNT(a.id) FILTER (WHERE a.status = 'completed') as completed_assignments_count
FROM crews c
LEFT JOIN assignments a ON c.id = a.crew_id
GROUP BY c.id
ORDER BY c.created_at DESC
LIMIT $1 OFFSET $2
`

type GetCrewsWithAssignmentStatsParams struct {
	Limit  int32
	Offset int32
}

type GetCrewsWithAssignmentStatsRow struct {
	ID                        int64
	PublicID                  uuid.UUID
	Name                      string
	CrewType                  CrewType
	Description               sql.NullString
	CreatedAt                 time.Time
	UpdatedAt                 sql.NullTime
	TotalAssignmentsCount     int64
	CurrentAssignmentsCount   int64
	CompletedAssignmentsCount int64
}

func (q *Queries) GetCrewsWithAssignmentStats(ctx context.Context, arg GetCrewsWithAssignmentStatsParams) ([]GetCrewsWithAssignmentStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCrewsWithAssignmentStats, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCrewsWithAssignmentStatsRow
	for rows.Next() {
		var i GetCrewsWithAssignmentStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.CrewType,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalAssignmentsCount,
			&i.CurrentAssignmentsCount,
			&i.CompletedAssignmentsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrews = `-- name: ListCrews :many
SELECT id, public_id, name, crew_type, description, created_at, updated_at FROM crews
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCrewsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListCrews(ctx context.Context, arg ListCrewsParams) ([]Crew, error) {
	rows, err := q.db.QueryContext(ctx, listCrews, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Crew
	for rows.Next() {
		var i Crew
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.CrewType,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrewsByType = `-- name: ListCrewsByType :many
SELECT id, public_id, name, crew_type, description, created_at, updated_at FROM crews
WHERE crew_type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListCrewsByTypeParams struct {
	CrewType CrewType
	Limit    int32
	Offset   int32
}

func (q *Queries) ListCrewsByType(ctx context.Context, arg ListCrewsByTypeParams) ([]Crew, error) {
	rows, err := q.db.QueryContext(ctx, listCrewsByType, arg.CrewType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Crew
	for rows.Next() {
		var i Crew
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.CrewType,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCrews = `-- name: SearchCrews :many
SELECT id, public_id, name, crew_type, description, created_at, updated_at FROM crews
WHERE name ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchCrewsParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchCrews(ctx context.Context, arg SearchCrewsParams) ([]Crew, error) {
	rows, err := q.db.QueryContext(ctx, searchCrews, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Crew
	for rows.Next() {
		var i Crew
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.CrewType,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCrew = `-- name: UpdateCrew :one
UPDATE crews
SET 
    name = $2,
    crew_type = $3,
    description = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, public_id, name, crew_type, description, created_at, updated_at
`

type UpdateCrewParams struct {
	ID          int64
	Name        string
	CrewType    CrewType
	Description sql.NullString
}

func (q *Queries) UpdateCrew(ctx context.Context, arg UpdateCrewParams) (Crew, error) {
	row := q.db.QueryRowContext(ctx, updateCrew,
		arg.ID,
		arg.Name,
		arg.CrewType,
		arg.Description,
	)
	var i Crew
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.CrewType,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
