// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outage_reports.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countOutageReportsByStatus = `-- name: CountOutageReportsByStatus :one
SELECT status, COUNT(*) as count
FROM outage_reports
GROUP BY status
`

type CountOutageReportsByStatusRow struct {
	Status ReportStatus
	Count  int64
}

func (q *Queries) CountOutageReportsByStatus(ctx context.Context) (CountOutageReportsByStatusRow, error) {
	row := q.db.QueryRowContext(ctx, countOutageReportsByStatus)
	var i CountOutageReportsByStatusRow
	err := row.Scan(&i.Status, &i.Count)
	return i, err
}

const createOutageReport = `-- name: CreateOutageReport :one
INSERT INTO outage_reports (
    reported_by,
    linked_outage_id,
    description,
    image_url,
    location,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status
`

type CreateOutageReportParams struct {
	ReportedBy     sql.NullInt64
	LinkedOutageID sql.NullInt64
	Description    sql.NullString
	ImageUrl       sql.NullString
	Location       interface{}
	Status         ReportStatus
}

func (q *Queries) CreateOutageReport(ctx context.Context, arg CreateOutageReportParams) (OutageReport, error) {
	row := q.db.QueryRowContext(ctx, createOutageReport,
		arg.ReportedBy,
		arg.LinkedOutageID,
		arg.Description,
		arg.ImageUrl,
		arg.Location,
		arg.Status,
	)
	var i OutageReport
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ReportedBy,
		&i.LinkedOutageID,
		&i.Description,
		&i.ImageUrl,
		&i.Location,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const deleteOutageReport = `-- name: DeleteOutageReport :exec
DELETE FROM outage_reports
WHERE id = $1
`

func (q *Queries) DeleteOutageReport(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOutageReport, id)
	return err
}

const getOutageReport = `-- name: GetOutageReport :one
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOutageReport(ctx context.Context, id int64) (OutageReport, error) {
	row := q.db.QueryRowContext(ctx, getOutageReport, id)
	var i OutageReport
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ReportedBy,
		&i.LinkedOutageID,
		&i.Description,
		&i.ImageUrl,
		&i.Location,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getOutageReportByPublicID = `-- name: GetOutageReportByPublicID :one
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
WHERE public_id = $1 LIMIT 1
`

func (q *Queries) GetOutageReportByPublicID(ctx context.Context, publicID uuid.UUID) (OutageReport, error) {
	row := q.db.QueryRowContext(ctx, getOutageReportByPublicID, publicID)
	var i OutageReport
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ReportedBy,
		&i.LinkedOutageID,
		&i.Description,
		&i.ImageUrl,
		&i.Location,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getRecentReportsInArea = `-- name: GetRecentReportsInArea :many
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
WHERE ST_Within(location, $1) -- $1 is polygon geometry
AND reported_at >= NOW() - INTERVAL '24 hours'
ORDER BY reported_at DESC
`

func (q *Queries) GetRecentReportsInArea(ctx context.Context, stWithin interface{}) ([]OutageReport, error) {
	rows, err := q.db.QueryContext(ctx, getRecentReportsInArea, stWithin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutageReport
	for rows.Next() {
		var i OutageReport
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ReportedBy,
			&i.LinkedOutageID,
			&i.Description,
			&i.ImageUrl,
			&i.Location,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsForOutage = `-- name: GetReportsForOutage :many
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
WHERE linked_outage_id = $1
ORDER BY reported_at DESC
`

func (q *Queries) GetReportsForOutage(ctx context.Context, linkedOutageID sql.NullInt64) ([]OutageReport, error) {
	rows, err := q.db.QueryContext(ctx, getReportsForOutage, linkedOutageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutageReport
	for rows.Next() {
		var i OutageReport
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ReportedBy,
			&i.LinkedOutageID,
			&i.Description,
			&i.ImageUrl,
			&i.Location,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkOutageReportToOutage = `-- name: LinkOutageReportToOutage :one
UPDATE outage_reports
SET 
    linked_outage_id = $2,
    status = 'processed_as_duplicate',
    updated_at = NOW()
WHERE id = $1
RETURNING id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status
`

type LinkOutageReportToOutageParams struct {
	ID             int64
	LinkedOutageID sql.NullInt64
}

func (q *Queries) LinkOutageReportToOutage(ctx context.Context, arg LinkOutageReportToOutageParams) (OutageReport, error) {
	row := q.db.QueryRowContext(ctx, linkOutageReportToOutage, arg.ID, arg.LinkedOutageID)
	var i OutageReport
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ReportedBy,
		&i.LinkedOutageID,
		&i.Description,
		&i.ImageUrl,
		&i.Location,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const listOutageReports = `-- name: ListOutageReports :many
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
ORDER BY reported_at DESC
LIMIT $1 OFFSET $2
`

type ListOutageReportsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListOutageReports(ctx context.Context, arg ListOutageReportsParams) ([]OutageReport, error) {
	rows, err := q.db.QueryContext(ctx, listOutageReports, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutageReport
	for rows.Next() {
		var i OutageReport
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ReportedBy,
			&i.LinkedOutageID,
			&i.Description,
			&i.ImageUrl,
			&i.Location,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutageReportsByReporter = `-- name: ListOutageReportsByReporter :many
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
WHERE reported_by = $1
ORDER BY reported_at DESC
LIMIT $2 OFFSET $3
`

type ListOutageReportsByReporterParams struct {
	ReportedBy sql.NullInt64
	Limit      int32
	Offset     int32
}

func (q *Queries) ListOutageReportsByReporter(ctx context.Context, arg ListOutageReportsByReporterParams) ([]OutageReport, error) {
	rows, err := q.db.QueryContext(ctx, listOutageReportsByReporter, arg.ReportedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutageReport
	for rows.Next() {
		var i OutageReport
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ReportedBy,
			&i.LinkedOutageID,
			&i.Description,
			&i.ImageUrl,
			&i.Location,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutageReportsByStatus = `-- name: ListOutageReportsByStatus :many
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
WHERE status = $1
ORDER BY reported_at DESC
LIMIT $2 OFFSET $3
`

type ListOutageReportsByStatusParams struct {
	Status ReportStatus
	Limit  int32
	Offset int32
}

func (q *Queries) ListOutageReportsByStatus(ctx context.Context, arg ListOutageReportsByStatusParams) ([]OutageReport, error) {
	rows, err := q.db.QueryContext(ctx, listOutageReportsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutageReport
	for rows.Next() {
		var i OutageReport
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ReportedBy,
			&i.LinkedOutageID,
			&i.Description,
			&i.ImageUrl,
			&i.Location,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedReports = `-- name: ListUnprocessedReports :many
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
WHERE status = 'unprocessed'
ORDER BY reported_at DESC
LIMIT $1 OFFSET $2
`

type ListUnprocessedReportsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListUnprocessedReports(ctx context.Context, arg ListUnprocessedReportsParams) ([]OutageReport, error) {
	rows, err := q.db.QueryContext(ctx, listUnprocessedReports, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutageReport
	for rows.Next() {
		var i OutageReport
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ReportedBy,
			&i.LinkedOutageID,
			&i.Description,
			&i.ImageUrl,
			&i.Location,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOutageReportsNearLocation = `-- name: SearchOutageReportsNearLocation :many
SELECT id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status FROM outage_reports
WHERE ST_DWithin(location, $1, $2) -- $1 is point geometry, $2 is distance in meters
ORDER BY reported_at DESC
LIMIT $3 OFFSET $4
`

type SearchOutageReportsNearLocationParams struct {
	StDwithin   interface{}
	StDwithin_2 interface{}
	Limit       int32
	Offset      int32
}

func (q *Queries) SearchOutageReportsNearLocation(ctx context.Context, arg SearchOutageReportsNearLocationParams) ([]OutageReport, error) {
	rows, err := q.db.QueryContext(ctx, searchOutageReportsNearLocation,
		arg.StDwithin,
		arg.StDwithin_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutageReport
	for rows.Next() {
		var i OutageReport
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.ReportedBy,
			&i.LinkedOutageID,
			&i.Description,
			&i.ImageUrl,
			&i.Location,
			&i.ReportedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOutageReport = `-- name: UpdateOutageReport :one
UPDATE outage_reports
SET 
    reported_by = $2,
    linked_outage_id = $3,
    description = $4,
    image_url = $5,
    location = $6,
    status = $7,
    updated_at = NOW()
WHERE id = $1
RETURNING id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status
`

type UpdateOutageReportParams struct {
	ID             int64
	ReportedBy     sql.NullInt64
	LinkedOutageID sql.NullInt64
	Description    sql.NullString
	ImageUrl       sql.NullString
	Location       interface{}
	Status         ReportStatus
}

func (q *Queries) UpdateOutageReport(ctx context.Context, arg UpdateOutageReportParams) (OutageReport, error) {
	row := q.db.QueryRowContext(ctx, updateOutageReport,
		arg.ID,
		arg.ReportedBy,
		arg.LinkedOutageID,
		arg.Description,
		arg.ImageUrl,
		arg.Location,
		arg.Status,
	)
	var i OutageReport
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ReportedBy,
		&i.LinkedOutageID,
		&i.Description,
		&i.ImageUrl,
		&i.Location,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const updateOutageReportStatus = `-- name: UpdateOutageReportStatus :one
UPDATE outage_reports
SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, public_id, reported_by, linked_outage_id, description, image_url, location, reported_at, updated_at, status
`

type UpdateOutageReportStatusParams struct {
	ID     int64
	Status ReportStatus
}

func (q *Queries) UpdateOutageReportStatus(ctx context.Context, arg UpdateOutageReportStatusParams) (OutageReport, error) {
	row := q.db.QueryRowContext(ctx, updateOutageReportStatus, arg.ID, arg.Status)
	var i OutageReport
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ReportedBy,
		&i.LinkedOutageID,
		&i.Description,
		&i.ImageUrl,
		&i.Location,
		&i.ReportedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const updateReportCountForOutage = `-- name: UpdateReportCountForOutage :exec
UPDATE outages 
SET number_of_reports = (
    SELECT COUNT(*) 
    FROM outage_reports 
    WHERE linked_outage_id = $1
)
WHERE id = $1
`

func (q *Queries) UpdateReportCountForOutage(ctx context.Context, linkedOutageID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, updateReportCountForOutage, linkedOutageID)
	return err
}
