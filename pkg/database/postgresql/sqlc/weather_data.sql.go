// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: weather_data.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const bulkInsertWeatherData = `-- name: BulkInsertWeatherData :exec
INSERT INTO weather_data (
    city_id,
    temperature,
    feels_like,
    humidity,
    atmospheric_pressure,
    wind_speed,
    precipitation,
    condition_main,
    condition_description,
    recorded_at
) VALUES 
    (UNNEST($1::bigint[]), 
     UNNEST($2::numeric[]), 
     UNNEST($3::numeric[]), 
     UNNEST($4::integer[]), 
     UNNEST($5::integer[]), 
     UNNEST($6::numeric[]), 
     UNNEST($7::numeric[]), 
     UNNEST($8::varchar[]), 
     UNNEST($9::text[]), 
     UNNEST($10::timestamptz[]))
`

type BulkInsertWeatherDataParams struct {
	Column1  []int64
	Column2  []string
	Column3  []string
	Column4  []int32
	Column5  []int32
	Column6  []string
	Column7  []string
	Column8  []string
	Column9  []string
	Column10 []time.Time
}

func (q *Queries) BulkInsertWeatherData(ctx context.Context, arg BulkInsertWeatherDataParams) error {
	_, err := q.db.ExecContext(ctx, bulkInsertWeatherData,
		pq.Array(arg.Column1),
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
		pq.Array(arg.Column5),
		pq.Array(arg.Column6),
		pq.Array(arg.Column7),
		pq.Array(arg.Column8),
		pq.Array(arg.Column9),
		pq.Array(arg.Column10),
	)
	return err
}

const countWeatherRecordsByCity = `-- name: CountWeatherRecordsByCity :one
SELECT city_id, COUNT(*) as record_count
FROM weather_data
GROUP BY city_id
`

type CountWeatherRecordsByCityRow struct {
	CityID      int64
	RecordCount int64
}

func (q *Queries) CountWeatherRecordsByCity(ctx context.Context) (CountWeatherRecordsByCityRow, error) {
	row := q.db.QueryRowContext(ctx, countWeatherRecordsByCity)
	var i CountWeatherRecordsByCityRow
	err := row.Scan(&i.CityID, &i.RecordCount)
	return i, err
}

const createWeatherData = `-- name: CreateWeatherData :one
INSERT INTO weather_data (
    city_id,
    temperature,
    feels_like,
    humidity,
    atmospheric_pressure,
    wind_speed,
    precipitation,
    condition_main,
    condition_description,
    recorded_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at
`

type CreateWeatherDataParams struct {
	CityID               int64
	Temperature          string
	FeelsLike            sql.NullString
	Humidity             sql.NullInt32
	AtmosphericPressure  sql.NullInt32
	WindSpeed            sql.NullString
	Precipitation        sql.NullString
	ConditionMain        sql.NullString
	ConditionDescription sql.NullString
	RecordedAt           time.Time
}

func (q *Queries) CreateWeatherData(ctx context.Context, arg CreateWeatherDataParams) (WeatherDatum, error) {
	row := q.db.QueryRowContext(ctx, createWeatherData,
		arg.CityID,
		arg.Temperature,
		arg.FeelsLike,
		arg.Humidity,
		arg.AtmosphericPressure,
		arg.WindSpeed,
		arg.Precipitation,
		arg.ConditionMain,
		arg.ConditionDescription,
		arg.RecordedAt,
	)
	var i WeatherDatum
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CityID,
		&i.Temperature,
		&i.FeelsLike,
		&i.Humidity,
		&i.AtmosphericPressure,
		&i.WindSpeed,
		&i.Precipitation,
		&i.ConditionMain,
		&i.ConditionDescription,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldWeatherData = `-- name: DeleteOldWeatherData :exec
DELETE FROM weather_data
WHERE recorded_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteOldWeatherData(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOldWeatherData)
	return err
}

const deleteWeatherData = `-- name: DeleteWeatherData :exec
DELETE FROM weather_data
WHERE id = $1
`

func (q *Queries) DeleteWeatherData(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteWeatherData, id)
	return err
}

const getExtremeWeatherConditions = `-- name: GetExtremeWeatherConditions :many
SELECT 
    wd.id, wd.public_id, wd.city_id, wd.temperature, wd.feels_like, wd.humidity, wd.atmospheric_pressure, wd.wind_speed, wd.precipitation, wd.condition_main, wd.condition_description, wd.recorded_at, wd.created_at,
    c.name as city_name,
    p.name as province_name
FROM weather_data wd
JOIN cities c ON wd.city_id = c.id
JOIN provinces p ON c.province_id = p.id
WHERE (temperature >= 35 OR temperature <= 10)
   OR wind_speed >= 50
   OR precipitation >= 50
   OR condition_main IN ('Thunderstorm', 'Heavy Rain', 'Storm')
ORDER BY recorded_at DESC
LIMIT $1 OFFSET $2
`

type GetExtremeWeatherConditionsParams struct {
	Limit  int32
	Offset int32
}

type GetExtremeWeatherConditionsRow struct {
	ID                   int64
	PublicID             uuid.UUID
	CityID               int64
	Temperature          string
	FeelsLike            sql.NullString
	Humidity             sql.NullInt32
	AtmosphericPressure  sql.NullInt32
	WindSpeed            sql.NullString
	Precipitation        sql.NullString
	ConditionMain        sql.NullString
	ConditionDescription sql.NullString
	RecordedAt           time.Time
	CreatedAt            time.Time
	CityName             string
	ProvinceName         string
}

func (q *Queries) GetExtremeWeatherConditions(ctx context.Context, arg GetExtremeWeatherConditionsParams) ([]GetExtremeWeatherConditionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getExtremeWeatherConditions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExtremeWeatherConditionsRow
	for rows.Next() {
		var i GetExtremeWeatherConditionsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CityID,
			&i.Temperature,
			&i.FeelsLike,
			&i.Humidity,
			&i.AtmosphericPressure,
			&i.WindSpeed,
			&i.Precipitation,
			&i.ConditionMain,
			&i.ConditionDescription,
			&i.RecordedAt,
			&i.CreatedAt,
			&i.CityName,
			&i.ProvinceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestWeatherDataByCity = `-- name: GetLatestWeatherDataByCity :one
SELECT id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at FROM weather_data
WHERE city_id = $1
ORDER BY recorded_at DESC
LIMIT 1
`

func (q *Queries) GetLatestWeatherDataByCity(ctx context.Context, cityID int64) (WeatherDatum, error) {
	row := q.db.QueryRowContext(ctx, getLatestWeatherDataByCity, cityID)
	var i WeatherDatum
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CityID,
		&i.Temperature,
		&i.FeelsLike,
		&i.Humidity,
		&i.AtmosphericPressure,
		&i.WindSpeed,
		&i.Precipitation,
		&i.ConditionMain,
		&i.ConditionDescription,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestWeatherForMultipleCities = `-- name: GetLatestWeatherForMultipleCities :many
WITH latest_weather AS (
    SELECT DISTINCT ON (city_id) id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at
    FROM weather_data
    ORDER BY city_id, recorded_at DESC
)
SELECT 
    lw.id, lw.public_id, lw.city_id, lw.temperature, lw.feels_like, lw.humidity, lw.atmospheric_pressure, lw.wind_speed, lw.precipitation, lw.condition_main, lw.condition_description, lw.recorded_at, lw.created_at,
    c.name as city_name,
    p.name as province_name
FROM latest_weather lw
JOIN cities c ON lw.city_id = c.id
JOIN provinces p ON c.province_id = p.id
WHERE c.id = ANY($1::bigint[])
ORDER BY c.name
`

type GetLatestWeatherForMultipleCitiesRow struct {
	ID                   int64
	PublicID             uuid.UUID
	CityID               int64
	Temperature          string
	FeelsLike            sql.NullString
	Humidity             sql.NullInt32
	AtmosphericPressure  sql.NullInt32
	WindSpeed            sql.NullString
	Precipitation        sql.NullString
	ConditionMain        sql.NullString
	ConditionDescription sql.NullString
	RecordedAt           time.Time
	CreatedAt            time.Time
	CityName             string
	ProvinceName         string
}

func (q *Queries) GetLatestWeatherForMultipleCities(ctx context.Context, dollar_1 []int64) ([]GetLatestWeatherForMultipleCitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestWeatherForMultipleCities, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestWeatherForMultipleCitiesRow
	for rows.Next() {
		var i GetLatestWeatherForMultipleCitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CityID,
			&i.Temperature,
			&i.FeelsLike,
			&i.Humidity,
			&i.AtmosphericPressure,
			&i.WindSpeed,
			&i.Precipitation,
			&i.ConditionMain,
			&i.ConditionDescription,
			&i.RecordedAt,
			&i.CreatedAt,
			&i.CityName,
			&i.ProvinceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeatherData = `-- name: GetWeatherData :one
SELECT id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at FROM weather_data
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWeatherData(ctx context.Context, id int64) (WeatherDatum, error) {
	row := q.db.QueryRowContext(ctx, getWeatherData, id)
	var i WeatherDatum
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CityID,
		&i.Temperature,
		&i.FeelsLike,
		&i.Humidity,
		&i.AtmosphericPressure,
		&i.WindSpeed,
		&i.Precipitation,
		&i.ConditionMain,
		&i.ConditionDescription,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getWeatherDataByCityAndTime = `-- name: GetWeatherDataByCityAndTime :one
SELECT id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at FROM weather_data
WHERE city_id = $1 AND recorded_at = $2
LIMIT 1
`

type GetWeatherDataByCityAndTimeParams struct {
	CityID     int64
	RecordedAt time.Time
}

func (q *Queries) GetWeatherDataByCityAndTime(ctx context.Context, arg GetWeatherDataByCityAndTimeParams) (WeatherDatum, error) {
	row := q.db.QueryRowContext(ctx, getWeatherDataByCityAndTime, arg.CityID, arg.RecordedAt)
	var i WeatherDatum
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CityID,
		&i.Temperature,
		&i.FeelsLike,
		&i.Humidity,
		&i.AtmosphericPressure,
		&i.WindSpeed,
		&i.Precipitation,
		&i.ConditionMain,
		&i.ConditionDescription,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getWeatherDataByPublicID = `-- name: GetWeatherDataByPublicID :one
SELECT id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at FROM weather_data
WHERE public_id = $1 LIMIT 1
`

func (q *Queries) GetWeatherDataByPublicID(ctx context.Context, publicID uuid.UUID) (WeatherDatum, error) {
	row := q.db.QueryRowContext(ctx, getWeatherDataByPublicID, publicID)
	var i WeatherDatum
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CityID,
		&i.Temperature,
		&i.FeelsLike,
		&i.Humidity,
		&i.AtmosphericPressure,
		&i.WindSpeed,
		&i.Precipitation,
		&i.ConditionMain,
		&i.ConditionDescription,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getWeatherDataInTimeRange = `-- name: GetWeatherDataInTimeRange :many
SELECT id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at FROM weather_data
WHERE city_id = $1
AND recorded_at BETWEEN $2 AND $3
ORDER BY recorded_at DESC
`

type GetWeatherDataInTimeRangeParams struct {
	CityID       int64
	RecordedAt   time.Time
	RecordedAt_2 time.Time
}

func (q *Queries) GetWeatherDataInTimeRange(ctx context.Context, arg GetWeatherDataInTimeRangeParams) ([]WeatherDatum, error) {
	rows, err := q.db.QueryContext(ctx, getWeatherDataInTimeRange, arg.CityID, arg.RecordedAt, arg.RecordedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WeatherDatum
	for rows.Next() {
		var i WeatherDatum
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CityID,
			&i.Temperature,
			&i.FeelsLike,
			&i.Humidity,
			&i.AtmosphericPressure,
			&i.WindSpeed,
			&i.Precipitation,
			&i.ConditionMain,
			&i.ConditionDescription,
			&i.RecordedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeatherDataWithCityDetails = `-- name: GetWeatherDataWithCityDetails :many
SELECT 
    wd.id, wd.public_id, wd.city_id, wd.temperature, wd.feels_like, wd.humidity, wd.atmospheric_pressure, wd.wind_speed, wd.precipitation, wd.condition_main, wd.condition_description, wd.recorded_at, wd.created_at,
    c.name as city_name,
    c.public_id as city_public_id,
    p.name as province_name
FROM weather_data wd
JOIN cities c ON wd.city_id = c.id
JOIN provinces p ON c.province_id = p.id
ORDER BY wd.recorded_at DESC
LIMIT $1 OFFSET $2
`

type GetWeatherDataWithCityDetailsParams struct {
	Limit  int32
	Offset int32
}

type GetWeatherDataWithCityDetailsRow struct {
	ID                   int64
	PublicID             uuid.UUID
	CityID               int64
	Temperature          string
	FeelsLike            sql.NullString
	Humidity             sql.NullInt32
	AtmosphericPressure  sql.NullInt32
	WindSpeed            sql.NullString
	Precipitation        sql.NullString
	ConditionMain        sql.NullString
	ConditionDescription sql.NullString
	RecordedAt           time.Time
	CreatedAt            time.Time
	CityName             string
	CityPublicID         uuid.UUID
	ProvinceName         string
}

func (q *Queries) GetWeatherDataWithCityDetails(ctx context.Context, arg GetWeatherDataWithCityDetailsParams) ([]GetWeatherDataWithCityDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeatherDataWithCityDetails, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeatherDataWithCityDetailsRow
	for rows.Next() {
		var i GetWeatherDataWithCityDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CityID,
			&i.Temperature,
			&i.FeelsLike,
			&i.Humidity,
			&i.AtmosphericPressure,
			&i.WindSpeed,
			&i.Precipitation,
			&i.ConditionMain,
			&i.ConditionDescription,
			&i.RecordedAt,
			&i.CreatedAt,
			&i.CityName,
			&i.CityPublicID,
			&i.ProvinceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeatherStatsByCity = `-- name: GetWeatherStatsByCity :many
SELECT 
    city_id,
    AVG(temperature) as avg_temperature,
    MIN(temperature) as min_temperature,
    MAX(temperature) as max_temperature,
    AVG(humidity) as avg_humidity,
    AVG(wind_speed) as avg_wind_speed,
    SUM(precipitation) as total_precipitation
FROM weather_data
WHERE city_id = $1
AND recorded_at >= NOW() - INTERVAL '7 days'
GROUP BY city_id
`

type GetWeatherStatsByCityRow struct {
	CityID             int64
	AvgTemperature     float64
	MinTemperature     interface{}
	MaxTemperature     interface{}
	AvgHumidity        float64
	AvgWindSpeed       float64
	TotalPrecipitation int64
}

func (q *Queries) GetWeatherStatsByCity(ctx context.Context, cityID int64) ([]GetWeatherStatsByCityRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeatherStatsByCity, cityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeatherStatsByCityRow
	for rows.Next() {
		var i GetWeatherStatsByCityRow
		if err := rows.Scan(
			&i.CityID,
			&i.AvgTemperature,
			&i.MinTemperature,
			&i.MaxTemperature,
			&i.AvgHumidity,
			&i.AvgWindSpeed,
			&i.TotalPrecipitation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeatherTrends = `-- name: GetWeatherTrends :many
SELECT 
    DATE(recorded_at) as date,
    AVG(temperature) as avg_temperature,
    AVG(humidity) as avg_humidity,
    AVG(wind_speed) as avg_wind_speed,
    SUM(precipitation) as total_precipitation
FROM weather_data
WHERE city_id = $1
AND recorded_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(recorded_at)
ORDER BY date DESC
`

type GetWeatherTrendsRow struct {
	Date               time.Time
	AvgTemperature     float64
	AvgHumidity        float64
	AvgWindSpeed       float64
	TotalPrecipitation int64
}

func (q *Queries) GetWeatherTrends(ctx context.Context, cityID int64) ([]GetWeatherTrendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeatherTrends, cityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeatherTrendsRow
	for rows.Next() {
		var i GetWeatherTrendsRow
		if err := rows.Scan(
			&i.Date,
			&i.AvgTemperature,
			&i.AvgHumidity,
			&i.AvgWindSpeed,
			&i.TotalPrecipitation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWeatherData = `-- name: ListWeatherData :many
SELECT id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at FROM weather_data
ORDER BY recorded_at DESC
LIMIT $1 OFFSET $2
`

type ListWeatherDataParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListWeatherData(ctx context.Context, arg ListWeatherDataParams) ([]WeatherDatum, error) {
	rows, err := q.db.QueryContext(ctx, listWeatherData, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WeatherDatum
	for rows.Next() {
		var i WeatherDatum
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CityID,
			&i.Temperature,
			&i.FeelsLike,
			&i.Humidity,
			&i.AtmosphericPressure,
			&i.WindSpeed,
			&i.Precipitation,
			&i.ConditionMain,
			&i.ConditionDescription,
			&i.RecordedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWeatherDataByCity = `-- name: ListWeatherDataByCity :many
SELECT id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at FROM weather_data
WHERE city_id = $1
ORDER BY recorded_at DESC
LIMIT $2 OFFSET $3
`

type ListWeatherDataByCityParams struct {
	CityID int64
	Limit  int32
	Offset int32
}

func (q *Queries) ListWeatherDataByCity(ctx context.Context, arg ListWeatherDataByCityParams) ([]WeatherDatum, error) {
	rows, err := q.db.QueryContext(ctx, listWeatherDataByCity, arg.CityID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WeatherDatum
	for rows.Next() {
		var i WeatherDatum
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CityID,
			&i.Temperature,
			&i.FeelsLike,
			&i.Humidity,
			&i.AtmosphericPressure,
			&i.WindSpeed,
			&i.Precipitation,
			&i.ConditionMain,
			&i.ConditionDescription,
			&i.RecordedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWeatherDataByCondition = `-- name: SearchWeatherDataByCondition :many
SELECT 
    wd.id, wd.public_id, wd.city_id, wd.temperature, wd.feels_like, wd.humidity, wd.atmospheric_pressure, wd.wind_speed, wd.precipitation, wd.condition_main, wd.condition_description, wd.recorded_at, wd.created_at,
    c.name as city_name
FROM weather_data wd
JOIN cities c ON wd.city_id = c.id
WHERE condition_main ILIKE '%' || $1 || '%' 
   OR condition_description ILIKE '%' || $1 || '%'
ORDER BY recorded_at DESC
LIMIT $2 OFFSET $3
`

type SearchWeatherDataByConditionParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

type SearchWeatherDataByConditionRow struct {
	ID                   int64
	PublicID             uuid.UUID
	CityID               int64
	Temperature          string
	FeelsLike            sql.NullString
	Humidity             sql.NullInt32
	AtmosphericPressure  sql.NullInt32
	WindSpeed            sql.NullString
	Precipitation        sql.NullString
	ConditionMain        sql.NullString
	ConditionDescription sql.NullString
	RecordedAt           time.Time
	CreatedAt            time.Time
	CityName             string
}

func (q *Queries) SearchWeatherDataByCondition(ctx context.Context, arg SearchWeatherDataByConditionParams) ([]SearchWeatherDataByConditionRow, error) {
	rows, err := q.db.QueryContext(ctx, searchWeatherDataByCondition, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchWeatherDataByConditionRow
	for rows.Next() {
		var i SearchWeatherDataByConditionRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CityID,
			&i.Temperature,
			&i.FeelsLike,
			&i.Humidity,
			&i.AtmosphericPressure,
			&i.WindSpeed,
			&i.Precipitation,
			&i.ConditionMain,
			&i.ConditionDescription,
			&i.RecordedAt,
			&i.CreatedAt,
			&i.CityName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWeatherData = `-- name: UpdateWeatherData :one
UPDATE weather_data
SET 
    city_id = $2,
    temperature = $3,
    feels_like = $4,
    humidity = $5,
    atmospheric_pressure = $6,
    wind_speed = $7,
    precipitation = $8,
    condition_main = $9,
    condition_description = $10,
    recorded_at = $11
WHERE id = $1
RETURNING id, public_id, city_id, temperature, feels_like, humidity, atmospheric_pressure, wind_speed, precipitation, condition_main, condition_description, recorded_at, created_at
`

type UpdateWeatherDataParams struct {
	ID                   int64
	CityID               int64
	Temperature          string
	FeelsLike            sql.NullString
	Humidity             sql.NullInt32
	AtmosphericPressure  sql.NullInt32
	WindSpeed            sql.NullString
	Precipitation        sql.NullString
	ConditionMain        sql.NullString
	ConditionDescription sql.NullString
	RecordedAt           time.Time
}

func (q *Queries) UpdateWeatherData(ctx context.Context, arg UpdateWeatherDataParams) (WeatherDatum, error) {
	row := q.db.QueryRowContext(ctx, updateWeatherData,
		arg.ID,
		arg.CityID,
		arg.Temperature,
		arg.FeelsLike,
		arg.Humidity,
		arg.AtmosphericPressure,
		arg.WindSpeed,
		arg.Precipitation,
		arg.ConditionMain,
		arg.ConditionDescription,
		arg.RecordedAt,
	)
	var i WeatherDatum
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CityID,
		&i.Temperature,
		&i.FeelsLike,
		&i.Humidity,
		&i.AtmosphericPressure,
		&i.WindSpeed,
		&i.Precipitation,
		&i.ConditionMain,
		&i.ConditionDescription,
		&i.RecordedAt,
		&i.CreatedAt,
	)
	return i, err
}
