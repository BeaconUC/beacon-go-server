// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: affected_areas.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const checkBarangayAffectedByOutage = `-- name: CheckBarangayAffectedByOutage :one
SELECT EXISTS(
    SELECT 1 FROM affected_areas 
    WHERE outage_id = $1 AND barangay_id = $2
) as is_affected
`

type CheckBarangayAffectedByOutageParams struct {
	OutageID   int64
	BarangayID int64
}

func (q *Queries) CheckBarangayAffectedByOutage(ctx context.Context, arg CheckBarangayAffectedByOutageParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkBarangayAffectedByOutage, arg.OutageID, arg.BarangayID)
	var is_affected bool
	err := row.Scan(&is_affected)
	return is_affected, err
}

const countAffectedBarangaysByOutage = `-- name: CountAffectedBarangaysByOutage :one
SELECT COUNT(*) as count
FROM affected_areas
WHERE outage_id = $1
`

func (q *Queries) CountAffectedBarangaysByOutage(ctx context.Context, outageID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAffectedBarangaysByOutage, outageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAffectedArea = `-- name: CreateAffectedArea :one
INSERT INTO affected_areas (
    outage_id,
    barangay_id
) VALUES (
    $1, $2
)
RETURNING id, outage_id, barangay_id, created_at
`

type CreateAffectedAreaParams struct {
	OutageID   int64
	BarangayID int64
}

func (q *Queries) CreateAffectedArea(ctx context.Context, arg CreateAffectedAreaParams) (AffectedArea, error) {
	row := q.db.QueryRowContext(ctx, createAffectedArea, arg.OutageID, arg.BarangayID)
	var i AffectedArea
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.BarangayID,
		&i.CreatedAt,
	)
	return i, err
}

const createMultipleAffectedAreas = `-- name: CreateMultipleAffectedAreas :exec
INSERT INTO affected_areas (outage_id, barangay_id)
SELECT $1, unnest($2::bigint[])
ON CONFLICT (outage_id, barangay_id) DO NOTHING
`

type CreateMultipleAffectedAreasParams struct {
	OutageID int64
	Column2  []int64
}

func (q *Queries) CreateMultipleAffectedAreas(ctx context.Context, arg CreateMultipleAffectedAreasParams) error {
	_, err := q.db.ExecContext(ctx, createMultipleAffectedAreas, arg.OutageID, pq.Array(arg.Column2))
	return err
}

const deleteAffectedArea = `-- name: DeleteAffectedArea :exec
DELETE FROM affected_areas
WHERE id = $1
`

func (q *Queries) DeleteAffectedArea(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAffectedArea, id)
	return err
}

const deleteAffectedAreaByOutageAndBarangay = `-- name: DeleteAffectedAreaByOutageAndBarangay :exec
DELETE FROM affected_areas
WHERE outage_id = $1 AND barangay_id = $2
`

type DeleteAffectedAreaByOutageAndBarangayParams struct {
	OutageID   int64
	BarangayID int64
}

func (q *Queries) DeleteAffectedAreaByOutageAndBarangay(ctx context.Context, arg DeleteAffectedAreaByOutageAndBarangayParams) error {
	_, err := q.db.ExecContext(ctx, deleteAffectedAreaByOutageAndBarangay, arg.OutageID, arg.BarangayID)
	return err
}

const deleteAllAffectedAreasForOutage = `-- name: DeleteAllAffectedAreasForOutage :exec
DELETE FROM affected_areas
WHERE outage_id = $1
`

func (q *Queries) DeleteAllAffectedAreasForOutage(ctx context.Context, outageID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllAffectedAreasForOutage, outageID)
	return err
}

const getAffectedArea = `-- name: GetAffectedArea :one
SELECT id, outage_id, barangay_id, created_at FROM affected_areas
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAffectedArea(ctx context.Context, id int64) (AffectedArea, error) {
	row := q.db.QueryRowContext(ctx, getAffectedArea, id)
	var i AffectedArea
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.BarangayID,
		&i.CreatedAt,
	)
	return i, err
}

const getAffectedAreaByOutageAndBarangay = `-- name: GetAffectedAreaByOutageAndBarangay :one
SELECT id, outage_id, barangay_id, created_at FROM affected_areas
WHERE outage_id = $1 AND barangay_id = $2 LIMIT 1
`

type GetAffectedAreaByOutageAndBarangayParams struct {
	OutageID   int64
	BarangayID int64
}

func (q *Queries) GetAffectedAreaByOutageAndBarangay(ctx context.Context, arg GetAffectedAreaByOutageAndBarangayParams) (AffectedArea, error) {
	row := q.db.QueryRowContext(ctx, getAffectedAreaByOutageAndBarangay, arg.OutageID, arg.BarangayID)
	var i AffectedArea
	err := row.Scan(
		&i.ID,
		&i.OutageID,
		&i.BarangayID,
		&i.CreatedAt,
	)
	return i, err
}

const getAffectedAreasWithDetails = `-- name: GetAffectedAreasWithDetails :many
SELECT 
    aa.id, aa.outage_id, aa.barangay_id, aa.created_at,
    o.public_id as outage_public_id,
    o.title as outage_title,
    o.status as outage_status,
    b.public_id as barangay_public_id,
    b.name as barangay_name,
    b.population as barangay_population,
    c.name as city_name,
    p.name as province_name
FROM affected_areas aa
JOIN outages o ON aa.outage_id = o.id
JOIN barangays b ON aa.barangay_id = b.id
JOIN cities c ON b.city_id = c.id
JOIN provinces p ON c.province_id = p.id
WHERE aa.outage_id = $1
ORDER BY b.name
`

type GetAffectedAreasWithDetailsRow struct {
	ID                 int64
	OutageID           int64
	BarangayID         int64
	CreatedAt          time.Time
	OutagePublicID     uuid.UUID
	OutageTitle        sql.NullString
	OutageStatus       OutageStatus
	BarangayPublicID   uuid.UUID
	BarangayName       string
	BarangayPopulation sql.NullInt32
	CityName           string
	ProvinceName       string
}

func (q *Queries) GetAffectedAreasWithDetails(ctx context.Context, outageID int64) ([]GetAffectedAreasWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAffectedAreasWithDetails, outageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAffectedAreasWithDetailsRow
	for rows.Next() {
		var i GetAffectedAreasWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.BarangayID,
			&i.CreatedAt,
			&i.OutagePublicID,
			&i.OutageTitle,
			&i.OutageStatus,
			&i.BarangayPublicID,
			&i.BarangayName,
			&i.BarangayPopulation,
			&i.CityName,
			&i.ProvinceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBarangayOutageHistory = `-- name: GetBarangayOutageHistory :many
SELECT 
    o.id, o.public_id, o.outage_type, o.status, o.confidence_percentage, o.title, o.description, o.number_of_reports, o.estimated_affected_population, o.start_time, o.estimated_restoration_time, o.actual_restoration_time, o.confirmed_by, o.resolved_by, o.created_at, o.updated_at,
    aa.created_at as affected_at
FROM outages o
JOIN affected_areas aa ON o.id = aa.outage_id
WHERE aa.barangay_id = $1
ORDER BY aa.created_at DESC
LIMIT $2 OFFSET $3
`

type GetBarangayOutageHistoryParams struct {
	BarangayID int64
	Limit      int32
	Offset     int32
}

type GetBarangayOutageHistoryRow struct {
	ID                          int64
	PublicID                    uuid.UUID
	OutageType                  OutageType
	Status                      OutageStatus
	ConfidencePercentage        sql.NullFloat64
	Title                       sql.NullString
	Description                 sql.NullString
	NumberOfReports             sql.NullInt32
	EstimatedAffectedPopulation sql.NullInt32
	StartTime                   sql.NullTime
	EstimatedRestorationTime    sql.NullTime
	ActualRestorationTime       sql.NullTime
	ConfirmedBy                 sql.NullInt64
	ResolvedBy                  sql.NullInt64
	CreatedAt                   time.Time
	UpdatedAt                   sql.NullTime
	AffectedAt                  time.Time
}

func (q *Queries) GetBarangayOutageHistory(ctx context.Context, arg GetBarangayOutageHistoryParams) ([]GetBarangayOutageHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getBarangayOutageHistory, arg.BarangayID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBarangayOutageHistoryRow
	for rows.Next() {
		var i GetBarangayOutageHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OutageType,
			&i.Status,
			&i.ConfidencePercentage,
			&i.Title,
			&i.Description,
			&i.NumberOfReports,
			&i.EstimatedAffectedPopulation,
			&i.StartTime,
			&i.EstimatedRestorationTime,
			&i.ActualRestorationTime,
			&i.ConfirmedBy,
			&i.ResolvedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AffectedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutageAffectedBarangays = `-- name: GetOutageAffectedBarangays :many
SELECT 
    b.id, b.public_id, b.name, b.city_id, b.feeder_id, b.boundary, b.population, b.population_year, b.created_at, b.updated_at,
    c.name as city_name,
    p.name as province_name
FROM barangays b
JOIN affected_areas aa ON b.id = aa.barangay_id
JOIN cities c ON b.city_id = c.id
JOIN provinces p ON c.province_id = p.id
WHERE aa.outage_id = $1
ORDER BY b.name
`

type GetOutageAffectedBarangaysRow struct {
	ID             int64
	PublicID       uuid.UUID
	Name           string
	CityID         int64
	FeederID       sql.NullInt64
	Boundary       interface{}
	Population     sql.NullInt32
	PopulationYear sql.NullInt16
	CreatedAt      time.Time
	UpdatedAt      sql.NullTime
	CityName       string
	ProvinceName   string
}

func (q *Queries) GetOutageAffectedBarangays(ctx context.Context, outageID int64) ([]GetOutageAffectedBarangaysRow, error) {
	rows, err := q.db.QueryContext(ctx, getOutageAffectedBarangays, outageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOutageAffectedBarangaysRow
	for rows.Next() {
		var i GetOutageAffectedBarangaysRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.CityID,
			&i.FeederID,
			&i.Boundary,
			&i.Population,
			&i.PopulationYear,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CityName,
			&i.ProvinceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutagesAffectingBarangay = `-- name: GetOutagesAffectingBarangay :many
SELECT 
    o.id, o.public_id, o.outage_type, o.status, o.confidence_percentage, o.title, o.description, o.number_of_reports, o.estimated_affected_population, o.start_time, o.estimated_restoration_time, o.actual_restoration_time, o.confirmed_by, o.resolved_by, o.created_at, o.updated_at,
    aa.created_at as affected_at
FROM outages o
JOIN affected_areas aa ON o.id = aa.outage_id
WHERE aa.barangay_id = $1
AND o.status IN ('unverified', 'verified', 'being_resolved')
ORDER BY aa.created_at DESC
`

type GetOutagesAffectingBarangayRow struct {
	ID                          int64
	PublicID                    uuid.UUID
	OutageType                  OutageType
	Status                      OutageStatus
	ConfidencePercentage        sql.NullFloat64
	Title                       sql.NullString
	Description                 sql.NullString
	NumberOfReports             sql.NullInt32
	EstimatedAffectedPopulation sql.NullInt32
	StartTime                   sql.NullTime
	EstimatedRestorationTime    sql.NullTime
	ActualRestorationTime       sql.NullTime
	ConfirmedBy                 sql.NullInt64
	ResolvedBy                  sql.NullInt64
	CreatedAt                   time.Time
	UpdatedAt                   sql.NullTime
	AffectedAt                  time.Time
}

func (q *Queries) GetOutagesAffectingBarangay(ctx context.Context, barangayID int64) ([]GetOutagesAffectingBarangayRow, error) {
	rows, err := q.db.QueryContext(ctx, getOutagesAffectingBarangay, barangayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOutagesAffectingBarangayRow
	for rows.Next() {
		var i GetOutagesAffectingBarangayRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OutageType,
			&i.Status,
			&i.ConfidencePercentage,
			&i.Title,
			&i.Description,
			&i.NumberOfReports,
			&i.EstimatedAffectedPopulation,
			&i.StartTime,
			&i.EstimatedRestorationTime,
			&i.ActualRestorationTime,
			&i.ConfirmedBy,
			&i.ResolvedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AffectedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalPopulationAffectedByOutage = `-- name: GetTotalPopulationAffectedByOutage :one
SELECT COALESCE(SUM(b.population), 0) as total_population_affected
FROM affected_areas aa
JOIN barangays b ON aa.barangay_id = b.id
WHERE aa.outage_id = $1
`

func (q *Queries) GetTotalPopulationAffectedByOutage(ctx context.Context, outageID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalPopulationAffectedByOutage, outageID)
	var total_population_affected interface{}
	err := row.Scan(&total_population_affected)
	return total_population_affected, err
}

const listAffectedAreas = `-- name: ListAffectedAreas :many
SELECT id, outage_id, barangay_id, created_at FROM affected_areas
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAffectedAreasParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAffectedAreas(ctx context.Context, arg ListAffectedAreasParams) ([]AffectedArea, error) {
	rows, err := q.db.QueryContext(ctx, listAffectedAreas, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AffectedArea
	for rows.Next() {
		var i AffectedArea
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.BarangayID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAffectedAreasByBarangay = `-- name: ListAffectedAreasByBarangay :many
SELECT id, outage_id, barangay_id, created_at FROM affected_areas
WHERE barangay_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAffectedAreasByBarangay(ctx context.Context, barangayID int64) ([]AffectedArea, error) {
	rows, err := q.db.QueryContext(ctx, listAffectedAreasByBarangay, barangayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AffectedArea
	for rows.Next() {
		var i AffectedArea
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.BarangayID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAffectedAreasByOutage = `-- name: ListAffectedAreasByOutage :many
SELECT id, outage_id, barangay_id, created_at FROM affected_areas
WHERE outage_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAffectedAreasByOutage(ctx context.Context, outageID int64) ([]AffectedArea, error) {
	rows, err := q.db.QueryContext(ctx, listAffectedAreasByOutage, outageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AffectedArea
	for rows.Next() {
		var i AffectedArea
		if err := rows.Scan(
			&i.ID,
			&i.OutageID,
			&i.BarangayID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
