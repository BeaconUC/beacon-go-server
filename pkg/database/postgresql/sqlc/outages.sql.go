// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outages.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countOutagesByStatus = `-- name: CountOutagesByStatus :one
SELECT status, COUNT(*) as count
FROM outages
GROUP BY status
`

type CountOutagesByStatusRow struct {
	Status OutageStatus
	Count  int64
}

func (q *Queries) CountOutagesByStatus(ctx context.Context) (CountOutagesByStatusRow, error) {
	row := q.db.QueryRowContext(ctx, countOutagesByStatus)
	var i CountOutagesByStatusRow
	err := row.Scan(&i.Status, &i.Count)
	return i, err
}

const createOutage = `-- name: CreateOutage :one
INSERT INTO outages (
    outage_type,
    status,
    confidence_percentage,
    title,
    description,
    number_of_reports,
    estimated_affected_population,
    start_time,
    estimated_restoration_time,
    actual_restoration_time,
    confirmed_by,
    resolved_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at
`

type CreateOutageParams struct {
	OutageType                  OutageType
	Status                      OutageStatus
	ConfidencePercentage        sql.NullFloat64
	Title                       sql.NullString
	Description                 sql.NullString
	NumberOfReports             sql.NullInt32
	EstimatedAffectedPopulation sql.NullInt32
	StartTime                   sql.NullTime
	EstimatedRestorationTime    sql.NullTime
	ActualRestorationTime       sql.NullTime
	ConfirmedBy                 sql.NullInt64
	ResolvedBy                  sql.NullInt64
}

func (q *Queries) CreateOutage(ctx context.Context, arg CreateOutageParams) (Outage, error) {
	row := q.db.QueryRowContext(ctx, createOutage,
		arg.OutageType,
		arg.Status,
		arg.ConfidencePercentage,
		arg.Title,
		arg.Description,
		arg.NumberOfReports,
		arg.EstimatedAffectedPopulation,
		arg.StartTime,
		arg.EstimatedRestorationTime,
		arg.ActualRestorationTime,
		arg.ConfirmedBy,
		arg.ResolvedBy,
	)
	var i Outage
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OutageType,
		&i.Status,
		&i.ConfidencePercentage,
		&i.Title,
		&i.Description,
		&i.NumberOfReports,
		&i.EstimatedAffectedPopulation,
		&i.StartTime,
		&i.EstimatedRestorationTime,
		&i.ActualRestorationTime,
		&i.ConfirmedBy,
		&i.ResolvedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOutage = `-- name: DeleteOutage :exec
DELETE FROM outages
WHERE id = $1
`

func (q *Queries) DeleteOutage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOutage, id)
	return err
}

const getOutage = `-- name: GetOutage :one
SELECT id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at FROM outages
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOutage(ctx context.Context, id int64) (Outage, error) {
	row := q.db.QueryRowContext(ctx, getOutage, id)
	var i Outage
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OutageType,
		&i.Status,
		&i.ConfidencePercentage,
		&i.Title,
		&i.Description,
		&i.NumberOfReports,
		&i.EstimatedAffectedPopulation,
		&i.StartTime,
		&i.EstimatedRestorationTime,
		&i.ActualRestorationTime,
		&i.ConfirmedBy,
		&i.ResolvedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOutageByPublicID = `-- name: GetOutageByPublicID :one
SELECT id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at FROM outages
WHERE public_id = $1 LIMIT 1
`

func (q *Queries) GetOutageByPublicID(ctx context.Context, publicID uuid.UUID) (Outage, error) {
	row := q.db.QueryRowContext(ctx, getOutageByPublicID, publicID)
	var i Outage
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OutageType,
		&i.Status,
		&i.ConfidencePercentage,
		&i.Title,
		&i.Description,
		&i.NumberOfReports,
		&i.EstimatedAffectedPopulation,
		&i.StartTime,
		&i.EstimatedRestorationTime,
		&i.ActualRestorationTime,
		&i.ConfirmedBy,
		&i.ResolvedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOutageSummary = `-- name: GetOutageSummary :one
SELECT id, public_id, status, affected_barangay_count, estimated_population_affected FROM outage_summary
WHERE id = $1
`

func (q *Queries) GetOutageSummary(ctx context.Context, id int64) (OutageSummary, error) {
	row := q.db.QueryRowContext(ctx, getOutageSummary, id)
	var i OutageSummary
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Status,
		&i.AffectedBarangayCount,
		&i.EstimatedPopulationAffected,
	)
	return i, err
}

const getOutagesWithAffectedAreas = `-- name: GetOutagesWithAffectedAreas :many
SELECT 
    o.id, o.public_id, o.outage_type, o.status, o.confidence_percentage, o.title, o.description, o.number_of_reports, o.estimated_affected_population, o.start_time, o.estimated_restoration_time, o.actual_restoration_time, o.confirmed_by, o.resolved_by, o.created_at, o.updated_at,
    COUNT(aa.barangay_id) as affected_barangay_count,
    COALESCE(SUM(b.population), 0) as total_population_affected
FROM outages o
LEFT JOIN affected_areas aa ON o.id = aa.outage_id
LEFT JOIN barangays b ON aa.barangay_id = b.id
GROUP BY o.id
ORDER BY o.created_at DESC
LIMIT $1 OFFSET $2
`

type GetOutagesWithAffectedAreasParams struct {
	Limit  int32
	Offset int32
}

type GetOutagesWithAffectedAreasRow struct {
	ID                          int64
	PublicID                    uuid.UUID
	OutageType                  OutageType
	Status                      OutageStatus
	ConfidencePercentage        sql.NullFloat64
	Title                       sql.NullString
	Description                 sql.NullString
	NumberOfReports             sql.NullInt32
	EstimatedAffectedPopulation sql.NullInt32
	StartTime                   sql.NullTime
	EstimatedRestorationTime    sql.NullTime
	ActualRestorationTime       sql.NullTime
	ConfirmedBy                 sql.NullInt64
	ResolvedBy                  sql.NullInt64
	CreatedAt                   time.Time
	UpdatedAt                   sql.NullTime
	AffectedBarangayCount       int64
	TotalPopulationAffected     interface{}
}

func (q *Queries) GetOutagesWithAffectedAreas(ctx context.Context, arg GetOutagesWithAffectedAreasParams) ([]GetOutagesWithAffectedAreasRow, error) {
	rows, err := q.db.QueryContext(ctx, getOutagesWithAffectedAreas, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOutagesWithAffectedAreasRow
	for rows.Next() {
		var i GetOutagesWithAffectedAreasRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OutageType,
			&i.Status,
			&i.ConfidencePercentage,
			&i.Title,
			&i.Description,
			&i.NumberOfReports,
			&i.EstimatedAffectedPopulation,
			&i.StartTime,
			&i.EstimatedRestorationTime,
			&i.ActualRestorationTime,
			&i.ConfirmedBy,
			&i.ResolvedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AffectedBarangayCount,
			&i.TotalPopulationAffected,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveOutages = `-- name: ListActiveOutages :many
SELECT id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at FROM outages
WHERE status IN ('unverified', 'verified', 'being_resolved')
ORDER BY created_at DESC
`

func (q *Queries) ListActiveOutages(ctx context.Context) ([]Outage, error) {
	rows, err := q.db.QueryContext(ctx, listActiveOutages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outage
	for rows.Next() {
		var i Outage
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OutageType,
			&i.Status,
			&i.ConfidencePercentage,
			&i.Title,
			&i.Description,
			&i.NumberOfReports,
			&i.EstimatedAffectedPopulation,
			&i.StartTime,
			&i.EstimatedRestorationTime,
			&i.ActualRestorationTime,
			&i.ConfirmedBy,
			&i.ResolvedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutageSummaries = `-- name: ListOutageSummaries :many
SELECT id, public_id, status, affected_barangay_count, estimated_population_affected FROM outage_summary
ORDER BY id DESC
LIMIT $1 OFFSET $2
`

type ListOutageSummariesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListOutageSummaries(ctx context.Context, arg ListOutageSummariesParams) ([]OutageSummary, error) {
	rows, err := q.db.QueryContext(ctx, listOutageSummaries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutageSummary
	for rows.Next() {
		var i OutageSummary
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Status,
			&i.AffectedBarangayCount,
			&i.EstimatedPopulationAffected,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutages = `-- name: ListOutages :many
SELECT id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at FROM outages
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOutagesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListOutages(ctx context.Context, arg ListOutagesParams) ([]Outage, error) {
	rows, err := q.db.QueryContext(ctx, listOutages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outage
	for rows.Next() {
		var i Outage
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OutageType,
			&i.Status,
			&i.ConfidencePercentage,
			&i.Title,
			&i.Description,
			&i.NumberOfReports,
			&i.EstimatedAffectedPopulation,
			&i.StartTime,
			&i.EstimatedRestorationTime,
			&i.ActualRestorationTime,
			&i.ConfirmedBy,
			&i.ResolvedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutagesByStatus = `-- name: ListOutagesByStatus :many
SELECT id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at FROM outages
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOutagesByStatusParams struct {
	Status OutageStatus
	Limit  int32
	Offset int32
}

func (q *Queries) ListOutagesByStatus(ctx context.Context, arg ListOutagesByStatusParams) ([]Outage, error) {
	rows, err := q.db.QueryContext(ctx, listOutagesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outage
	for rows.Next() {
		var i Outage
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OutageType,
			&i.Status,
			&i.ConfidencePercentage,
			&i.Title,
			&i.Description,
			&i.NumberOfReports,
			&i.EstimatedAffectedPopulation,
			&i.StartTime,
			&i.EstimatedRestorationTime,
			&i.ActualRestorationTime,
			&i.ConfirmedBy,
			&i.ResolvedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutagesByType = `-- name: ListOutagesByType :many
SELECT id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at FROM outages
WHERE outage_type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOutagesByTypeParams struct {
	OutageType OutageType
	Limit      int32
	Offset     int32
}

func (q *Queries) ListOutagesByType(ctx context.Context, arg ListOutagesByTypeParams) ([]Outage, error) {
	rows, err := q.db.QueryContext(ctx, listOutagesByType, arg.OutageType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outage
	for rows.Next() {
		var i Outage
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OutageType,
			&i.Status,
			&i.ConfidencePercentage,
			&i.Title,
			&i.Description,
			&i.NumberOfReports,
			&i.EstimatedAffectedPopulation,
			&i.StartTime,
			&i.EstimatedRestorationTime,
			&i.ActualRestorationTime,
			&i.ConfirmedBy,
			&i.ResolvedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOutages = `-- name: SearchOutages :many
SELECT id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at FROM outages
WHERE 
    (title ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%')
    AND ($2::outage_status IS NULL OR status = $2)
    AND ($3::outage_type IS NULL OR outage_type = $3)
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type SearchOutagesParams struct {
	Column1 sql.NullString
	Column2 OutageStatus
	Column3 OutageType
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchOutages(ctx context.Context, arg SearchOutagesParams) ([]Outage, error) {
	rows, err := q.db.QueryContext(ctx, searchOutages,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outage
	for rows.Next() {
		var i Outage
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.OutageType,
			&i.Status,
			&i.ConfidencePercentage,
			&i.Title,
			&i.Description,
			&i.NumberOfReports,
			&i.EstimatedAffectedPopulation,
			&i.StartTime,
			&i.EstimatedRestorationTime,
			&i.ActualRestorationTime,
			&i.ConfirmedBy,
			&i.ResolvedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOutage = `-- name: UpdateOutage :one
UPDATE outages
SET 
    outage_type = $2,
    status = $3,
    confidence_percentage = $4,
    title = $5,
    description = $6,
    number_of_reports = $7,
    estimated_affected_population = $8,
    start_time = $9,
    estimated_restoration_time = $10,
    actual_restoration_time = $11,
    confirmed_by = $12,
    resolved_by = $13,
    updated_at = NOW()
WHERE id = $1
RETURNING id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at
`

type UpdateOutageParams struct {
	ID                          int64
	OutageType                  OutageType
	Status                      OutageStatus
	ConfidencePercentage        sql.NullFloat64
	Title                       sql.NullString
	Description                 sql.NullString
	NumberOfReports             sql.NullInt32
	EstimatedAffectedPopulation sql.NullInt32
	StartTime                   sql.NullTime
	EstimatedRestorationTime    sql.NullTime
	ActualRestorationTime       sql.NullTime
	ConfirmedBy                 sql.NullInt64
	ResolvedBy                  sql.NullInt64
}

func (q *Queries) UpdateOutage(ctx context.Context, arg UpdateOutageParams) (Outage, error) {
	row := q.db.QueryRowContext(ctx, updateOutage,
		arg.ID,
		arg.OutageType,
		arg.Status,
		arg.ConfidencePercentage,
		arg.Title,
		arg.Description,
		arg.NumberOfReports,
		arg.EstimatedAffectedPopulation,
		arg.StartTime,
		arg.EstimatedRestorationTime,
		arg.ActualRestorationTime,
		arg.ConfirmedBy,
		arg.ResolvedBy,
	)
	var i Outage
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OutageType,
		&i.Status,
		&i.ConfidencePercentage,
		&i.Title,
		&i.Description,
		&i.NumberOfReports,
		&i.EstimatedAffectedPopulation,
		&i.StartTime,
		&i.EstimatedRestorationTime,
		&i.ActualRestorationTime,
		&i.ConfirmedBy,
		&i.ResolvedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOutageStatus = `-- name: UpdateOutageStatus :one
UPDATE outages
SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, public_id, outage_type, status, confidence_percentage, title, description, number_of_reports, estimated_affected_population, start_time, estimated_restoration_time, actual_restoration_time, confirmed_by, resolved_by, created_at, updated_at
`

type UpdateOutageStatusParams struct {
	ID     int64
	Status OutageStatus
}

func (q *Queries) UpdateOutageStatus(ctx context.Context, arg UpdateOutageStatusParams) (Outage, error) {
	row := q.db.QueryRowContext(ctx, updateOutageStatus, arg.ID, arg.Status)
	var i Outage
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.OutageType,
		&i.Status,
		&i.ConfidencePercentage,
		&i.Title,
		&i.Description,
		&i.NumberOfReports,
		&i.EstimatedAffectedPopulation,
		&i.StartTime,
		&i.EstimatedRestorationTime,
		&i.ActualRestorationTime,
		&i.ConfirmedBy,
		&i.ResolvedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
