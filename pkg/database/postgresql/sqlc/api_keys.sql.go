// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_keys.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const bulkDeactivateApiKeys = `-- name: BulkDeactivateApiKeys :exec
UPDATE api_keys
SET is_active = false
WHERE created_by = $1
`

func (q *Queries) BulkDeactivateApiKeys(ctx context.Context, createdBy sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, bulkDeactivateApiKeys, createdBy)
	return err
}

const countApiKeysByStatus = `-- name: CountApiKeysByStatus :one
SELECT is_active, COUNT(*) as count
FROM api_keys
GROUP BY is_active
`

type CountApiKeysByStatusRow struct {
	IsActive bool
	Count    int64
}

func (q *Queries) CountApiKeysByStatus(ctx context.Context) (CountApiKeysByStatusRow, error) {
	row := q.db.QueryRowContext(ctx, countApiKeysByStatus)
	var i CountApiKeysByStatusRow
	err := row.Scan(&i.IsActive, &i.Count)
	return i, err
}

const createApiKey = `-- name: CreateApiKey :one
INSERT INTO api_keys (
    name,
    api_key,
    secret_key,
    service_name,
    is_active,
    rate_limit_per_minute,
    created_by,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at
`

type CreateApiKeyParams struct {
	Name               string
	ApiKey             string
	SecretKey          sql.NullString
	ServiceName        sql.NullString
	IsActive           bool
	RateLimitPerMinute sql.NullInt32
	CreatedBy          sql.NullInt64
	ExpiresAt          sql.NullTime
}

func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, createApiKey,
		arg.Name,
		arg.ApiKey,
		arg.SecretKey,
		arg.ServiceName,
		arg.IsActive,
		arg.RateLimitPerMinute,
		arg.CreatedBy,
		arg.ExpiresAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
DELETE FROM api_keys
WHERE id = $1
`

func (q *Queries) DeleteApiKey(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteApiKey, id)
	return err
}

const deleteExpiredApiKeys = `-- name: DeleteExpiredApiKeys :exec
DELETE FROM api_keys
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredApiKeys(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredApiKeys)
	return err
}

const getApiKey = `-- name: GetApiKey :one
SELECT id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at FROM api_keys
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetApiKey(ctx context.Context, id int64) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getApiKey, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getApiKeyByApiKey = `-- name: GetApiKeyByApiKey :one
SELECT id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at FROM api_keys
WHERE api_key = $1 LIMIT 1
`

func (q *Queries) GetApiKeyByApiKey(ctx context.Context, apiKey string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getApiKeyByApiKey, apiKey)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getApiKeyByPublicID = `-- name: GetApiKeyByPublicID :one
SELECT id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at FROM api_keys
WHERE public_id = $1 LIMIT 1
`

func (q *Queries) GetApiKeyByPublicID(ctx context.Context, publicID uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getApiKeyByPublicID, publicID)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getApiKeyUsageStats = `-- name: GetApiKeyUsageStats :many
SELECT 
    ak.name,
    ak.service_name,
    ak.is_active,
    ak.rate_limit_per_minute,
    ak.created_at,
    p.first_name as creator_first_name,
    p.last_name as creator_last_name
FROM api_keys ak
LEFT JOIN profiles p ON ak.created_by = p.id
ORDER BY ak.created_at DESC
LIMIT $1 OFFSET $2
`

type GetApiKeyUsageStatsParams struct {
	Limit  int32
	Offset int32
}

type GetApiKeyUsageStatsRow struct {
	Name               string
	ServiceName        sql.NullString
	IsActive           bool
	RateLimitPerMinute sql.NullInt32
	CreatedAt          time.Time
	CreatorFirstName   sql.NullString
	CreatorLastName    sql.NullString
}

func (q *Queries) GetApiKeyUsageStats(ctx context.Context, arg GetApiKeyUsageStatsParams) ([]GetApiKeyUsageStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getApiKeyUsageStats, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApiKeyUsageStatsRow
	for rows.Next() {
		var i GetApiKeyUsageStatsRow
		if err := rows.Scan(
			&i.Name,
			&i.ServiceName,
			&i.IsActive,
			&i.RateLimitPerMinute,
			&i.CreatedAt,
			&i.CreatorFirstName,
			&i.CreatorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeyWithCreator = `-- name: GetApiKeyWithCreator :one
SELECT 
    ak.id, ak.public_id, ak.name, ak.api_key, ak.secret_key, ak.service_name, ak.is_active, ak.rate_limit_per_minute, ak.created_by, ak.created_at, ak.expires_at,
    p.public_id as creator_public_id,
    p.first_name as creator_first_name,
    p.last_name as creator_last_name
FROM api_keys ak
LEFT JOIN profiles p ON ak.created_by = p.id
WHERE ak.id = $1
`

type GetApiKeyWithCreatorRow struct {
	ID                 int64
	PublicID           uuid.UUID
	Name               string
	ApiKey             string
	SecretKey          sql.NullString
	ServiceName        sql.NullString
	IsActive           bool
	RateLimitPerMinute sql.NullInt32
	CreatedBy          sql.NullInt64
	CreatedAt          time.Time
	ExpiresAt          sql.NullTime
	CreatorPublicID    uuid.NullUUID
	CreatorFirstName   sql.NullString
	CreatorLastName    sql.NullString
}

func (q *Queries) GetApiKeyWithCreator(ctx context.Context, id int64) (GetApiKeyWithCreatorRow, error) {
	row := q.db.QueryRowContext(ctx, getApiKeyWithCreator, id)
	var i GetApiKeyWithCreatorRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.CreatorPublicID,
		&i.CreatorFirstName,
		&i.CreatorLastName,
	)
	return i, err
}

const getApiKeysExpiringSoon = `-- name: GetApiKeysExpiringSoon :many
SELECT id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at FROM api_keys
WHERE expires_at BETWEEN NOW() AND NOW() + INTERVAL '7 days'
AND is_active = true
ORDER BY expires_at ASC
`

func (q *Queries) GetApiKeysExpiringSoon(ctx context.Context) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, getApiKeysExpiringSoon)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.ApiKey,
			&i.SecretKey,
			&i.ServiceName,
			&i.IsActive,
			&i.RateLimitPerMinute,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveApiKeys = `-- name: ListActiveApiKeys :many
SELECT id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at FROM api_keys
WHERE is_active = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListActiveApiKeysParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListActiveApiKeys(ctx context.Context, arg ListActiveApiKeysParams) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, listActiveApiKeys, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.ApiKey,
			&i.SecretKey,
			&i.ServiceName,
			&i.IsActive,
			&i.RateLimitPerMinute,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApiKeys = `-- name: ListApiKeys :many
SELECT id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at FROM api_keys
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListApiKeysParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListApiKeys(ctx context.Context, arg ListApiKeysParams) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, listApiKeys, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.ApiKey,
			&i.SecretKey,
			&i.ServiceName,
			&i.IsActive,
			&i.RateLimitPerMinute,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApiKeysByCreator = `-- name: ListApiKeysByCreator :many
SELECT id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at FROM api_keys
WHERE created_by = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListApiKeysByCreatorParams struct {
	CreatedBy sql.NullInt64
	Limit     int32
	Offset    int32
}

func (q *Queries) ListApiKeysByCreator(ctx context.Context, arg ListApiKeysByCreatorParams) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, listApiKeysByCreator, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.ApiKey,
			&i.SecretKey,
			&i.ServiceName,
			&i.IsActive,
			&i.RateLimitPerMinute,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rotateApiKey = `-- name: RotateApiKey :one
UPDATE api_keys
SET 
    api_key = $2,
    secret_key = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at
`

type RotateApiKeyParams struct {
	ID        int64
	ApiKey    string
	SecretKey sql.NullString
}

func (q *Queries) RotateApiKey(ctx context.Context, arg RotateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, rotateApiKey, arg.ID, arg.ApiKey, arg.SecretKey)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const searchApiKeys = `-- name: SearchApiKeys :many
SELECT id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at FROM api_keys
WHERE name ILIKE '%' || $1 || '%' OR service_name ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchApiKeysParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchApiKeys(ctx context.Context, arg SearchApiKeysParams) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, searchApiKeys, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.ApiKey,
			&i.SecretKey,
			&i.ServiceName,
			&i.IsActive,
			&i.RateLimitPerMinute,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleApiKeyActive = `-- name: ToggleApiKeyActive :one
UPDATE api_keys
SET 
    is_active = $2
WHERE id = $1
RETURNING id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at
`

type ToggleApiKeyActiveParams struct {
	ID       int64
	IsActive bool
}

func (q *Queries) ToggleApiKeyActive(ctx context.Context, arg ToggleApiKeyActiveParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, toggleApiKeyActive, arg.ID, arg.IsActive)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateApiKey = `-- name: UpdateApiKey :one
UPDATE api_keys
SET 
    name = $2,
    api_key = $3,
    secret_key = $4,
    service_name = $5,
    is_active = $6,
    rate_limit_per_minute = $7,
    expires_at = $8
WHERE id = $1
RETURNING id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at
`

type UpdateApiKeyParams struct {
	ID                 int64
	Name               string
	ApiKey             string
	SecretKey          sql.NullString
	ServiceName        sql.NullString
	IsActive           bool
	RateLimitPerMinute sql.NullInt32
	ExpiresAt          sql.NullTime
}

func (q *Queries) UpdateApiKey(ctx context.Context, arg UpdateApiKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, updateApiKey,
		arg.ID,
		arg.Name,
		arg.ApiKey,
		arg.SecretKey,
		arg.ServiceName,
		arg.IsActive,
		arg.RateLimitPerMinute,
		arg.ExpiresAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateApiKeyRateLimit = `-- name: UpdateApiKeyRateLimit :one
UPDATE api_keys
SET 
    rate_limit_per_minute = $2
WHERE id = $1
RETURNING id, public_id, name, api_key, secret_key, service_name, is_active, rate_limit_per_minute, created_by, created_at, expires_at
`

type UpdateApiKeyRateLimitParams struct {
	ID                 int64
	RateLimitPerMinute sql.NullInt32
}

func (q *Queries) UpdateApiKeyRateLimit(ctx context.Context, arg UpdateApiKeyRateLimitParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, updateApiKeyRateLimit, arg.ID, arg.RateLimitPerMinute)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const validateApiKey = `-- name: ValidateApiKey :one
SELECT 
    ak.id, ak.public_id, ak.name, ak.api_key, ak.secret_key, ak.service_name, ak.is_active, ak.rate_limit_per_minute, ak.created_by, ak.created_at, ak.expires_at,
    p.role as creator_role
FROM api_keys ak
LEFT JOIN profiles p ON ak.created_by = p.id
WHERE ak.api_key = $1 
AND ak.is_active = true
AND (ak.expires_at IS NULL OR ak.expires_at > NOW())
LIMIT 1
`

type ValidateApiKeyRow struct {
	ID                 int64
	PublicID           uuid.UUID
	Name               string
	ApiKey             string
	SecretKey          sql.NullString
	ServiceName        sql.NullString
	IsActive           bool
	RateLimitPerMinute sql.NullInt32
	CreatedBy          sql.NullInt64
	CreatedAt          time.Time
	ExpiresAt          sql.NullTime
	CreatorRole        NullRoles
}

func (q *Queries) ValidateApiKey(ctx context.Context, apiKey string) (ValidateApiKeyRow, error) {
	row := q.db.QueryRowContext(ctx, validateApiKey, apiKey)
	var i ValidateApiKeyRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.ApiKey,
		&i.SecretKey,
		&i.ServiceName,
		&i.IsActive,
		&i.RateLimitPerMinute,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.CreatorRole,
	)
	return i, err
}
